#ifndef _REACT_NATIVE_HASKELL_SHELLEY_
#define _REACT_NATIVE_HASKELL_SHELLEY_

/* Generated with cbindgen:0.14.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

typedef const char *CharPtr;

typedef struct {
  void *_0;
} RPtr;

typedef struct {
  const uint8_t *ptr;
  uintptr_t len;
} DataPtr;

bool address_from_bech32(CharPtr chars, RPtr *result, CharPtr *error);

bool address_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool address_to_bech32(RPtr rptr, CharPtr *result, CharPtr *error);

bool address_to_bytes(RPtr address, DataPtr *result, CharPtr *error);

bool base_address_from_address(RPtr rptr, RPtr *result, CharPtr *error);

bool base_address_new(uint8_t network, RPtr payment, RPtr stake, RPtr *result, CharPtr *error);

bool base_address_payment_cred(RPtr base_address, RPtr *result, CharPtr *error);

bool base_address_stake_cred(RPtr base_address, RPtr *result, CharPtr *error);

bool base_address_to_address(RPtr rptr, RPtr *result, CharPtr *error);

bool big_num_checked_add(RPtr big_num, RPtr other, RPtr *result, CharPtr *error);

bool big_num_checked_sub(RPtr big_num, RPtr other, RPtr *result, CharPtr *error);

bool big_num_from_str(CharPtr chars, RPtr *result, CharPtr *error);

bool big_num_to_str(RPtr big_num, CharPtr *result, CharPtr *error);

bool bip_32_private_key_as_bytes(RPtr bip_32_private_key, DataPtr *result, CharPtr *error);

bool bip_32_private_key_derive(RPtr bip_32_private_key,
                               int64_t index,
                               RPtr *result,
                               CharPtr *error);

bool bip_32_private_key_from_bech32(CharPtr bech32_str, RPtr *result, CharPtr *error);

bool bip_32_private_key_from_bip39_entropy(const uint8_t *entropy_data,
                                           uintptr_t entropy_len,
                                           const uint8_t *password_data,
                                           uintptr_t password_len,
                                           RPtr *result,
                                           CharPtr *error);

bool bip_32_private_key_from_bytes(const uint8_t *data,
                                   uintptr_t len,
                                   RPtr *result,
                                   CharPtr *error);

bool bip_32_private_key_generate_ed25519_bip32(RPtr *result, CharPtr *error);

bool bip_32_private_key_to_bech32(RPtr bip_32_private_key, CharPtr *result, CharPtr *error);

bool bip_32_private_key_to_public(RPtr bip_32_private_key, RPtr *result, CharPtr *error);

bool bip_32_private_key_to_raw_key(RPtr bip_32_private_key, RPtr *result, CharPtr *error);

bool bip_32_public_key_to_raw_key(RPtr bip_32_public_key, RPtr *result, CharPtr *error);

bool bootstrap_witnesses_add(RPtr *witnesses, RPtr item, CharPtr *error);

bool bootstrap_witnesses_len(RPtr witnesses, uintptr_t *result, CharPtr *error);

bool bootstrap_witnesses_new(RPtr *result, CharPtr *error);

bool byron_address_from_address(RPtr rptr, RPtr *result, CharPtr *error);

bool byron_address_from_base58(CharPtr chars, RPtr *result, CharPtr *error);

bool byron_address_from_icarus_key(RPtr bip_32_public_key,
                                   uint8_t network,
                                   RPtr *result,
                                   CharPtr *error);

bool byron_address_is_valid(CharPtr chars, bool *result, CharPtr *error);

bool byron_address_to_address(RPtr rptr, RPtr *result, CharPtr *error);

bool byron_address_to_base58(RPtr rptr, CharPtr *result, CharPtr *error);

void charptr_free(CharPtr *ptr);

char *create_rootkey(const char *mnemonics, const char *password);

void dataptr_free(DataPtr *data);

bool ed25519_key_hash_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool ed25519_key_hash_to_bytes(RPtr ed25519_key_hash, DataPtr *result, CharPtr *error);

void init_haskell_shelley_library(void);

bool legacy_daedalus_private_key_from_bytes(const uint8_t *data,
                                            uintptr_t len,
                                            RPtr *result,
                                            CharPtr *error);

bool linear_fee_coefficient(RPtr rptr, RPtr *result, CharPtr *error);

bool linear_fee_constant(RPtr rptr, RPtr *result, CharPtr *error);

bool linear_fee_new(RPtr coefficient, RPtr constant, RPtr *result, CharPtr *error);

bool public_key_hash(RPtr public_key, RPtr *result, CharPtr *error);

void rptr_free(RPtr *ptr);

RPtr rptr_from_usize(uintptr_t usz);

uintptr_t rptr_into_usize(RPtr ptr);

bool stake_credential_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool stake_credential_from_keyhash(RPtr keyhash, RPtr *result, CharPtr *error);

bool stake_credential_to_bytes(RPtr stake_credential, DataPtr *result, CharPtr *error);

bool stake_credential_to_keyhash(RPtr stake_credential, RPtr *result, CharPtr *error);

bool stake_credential_to_kind(RPtr stake_credential, uint8_t *result, CharPtr *error);

bool transaction_body(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_body_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool transaction_body_to_bytes(RPtr transaction_body, DataPtr *result, CharPtr *error);

bool transaction_builder_add_bootstrap_input(RPtr tx_builder,
                                             RPtr hash,
                                             RPtr input,
                                             RPtr amount,
                                             CharPtr *error);

bool transaction_builder_add_change_if_needed(RPtr rptr,
                                              RPtr address,
                                              bool *result,
                                              CharPtr *error);

bool transaction_builder_add_key_input(RPtr tx_builder,
                                       RPtr hash,
                                       RPtr input,
                                       RPtr amount,
                                       CharPtr *error);

bool transaction_builder_add_output(RPtr tx_builder, RPtr output, CharPtr *error);

bool transaction_builder_build(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_estimate_fee(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_get_explicit_input(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_get_explicit_output(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_get_fee_or_calc(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_get_implicit_input(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_new(RPtr linear_fee,
                             RPtr minimum_utxo_val,
                             RPtr pool_deposit,
                             RPtr key_deposit,
                             RPtr *result,
                             CharPtr *error);

bool transaction_builder_set_fee(RPtr tx_builder, RPtr fee, CharPtr *error);

bool transaction_builder_set_ttl(RPtr tx_builder, uint32_t ttl, CharPtr *error);

bool transaction_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool transaction_hash_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool transaction_hash_to_bytes(RPtr transaction_hash, DataPtr *result, CharPtr *error);

bool transaction_input_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool transaction_input_index(RPtr transaction_input, uint32_t *result, CharPtr *error);

bool transaction_input_new(RPtr transaction_id, uint32_t index, RPtr *result, CharPtr *error);

bool transaction_input_to_bytes(RPtr transaction_input, DataPtr *result, CharPtr *error);

bool transaction_input_transaction_id(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_new(RPtr body, RPtr witness_set, RPtr *result, CharPtr *error);

bool transaction_new_with_metadata(RPtr body,
                                   RPtr witness_set,
                                   RPtr *metadata,
                                   RPtr *result,
                                   CharPtr *error);

bool transaction_output_from_bytes(const uint8_t *data,
                                   uintptr_t len,
                                   RPtr *result,
                                   CharPtr *error);

bool transaction_output_new(RPtr address, RPtr amount, RPtr *result, CharPtr *error);

bool transaction_output_to_bytes(RPtr transaction_output, DataPtr *result, CharPtr *error);

bool transaction_to_bytes(RPtr transaction, DataPtr *result, CharPtr *error);

bool transaction_witness_set_new(RPtr *result, CharPtr *error);

bool transaction_witness_set_set_bootstraps(RPtr transaction_witness_set,
                                            RPtr bootstrap_witnesses,
                                            CharPtr *error);

bool transaction_witness_set_set_vkeys(RPtr transaction_witness_set,
                                       RPtr vkeywitnesses,
                                       CharPtr *error);

bool unit_interval_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool unit_interval_new(RPtr numerator, RPtr denominator, RPtr *result, CharPtr *error);

bool unit_interval_to_bytes(RPtr unit_interval, DataPtr *result, CharPtr *error);

bool utils_hash_transaction(RPtr tx_body, RPtr *result, CharPtr *error);

bool utils_make_daedalus_bootstrap_witness(RPtr tx_body_hash,
                                           RPtr addr,
                                           RPtr key,
                                           RPtr *result,
                                           CharPtr *error);

bool utils_make_icarus_bootstrap_witness(RPtr tx_body_hash,
                                         RPtr addr,
                                         RPtr key,
                                         RPtr *result,
                                         CharPtr *error);

bool utils_make_vkey_witness(RPtr tx_body_hash, RPtr sk, RPtr *result, CharPtr *error);

bool vkeywitnesses_add(RPtr *witnesses, RPtr item, CharPtr *error);

bool vkeywitnesses_len(RPtr witnesses, uintptr_t *result, CharPtr *error);

bool vkeywitnesses_new(RPtr *result, CharPtr *error);

#endif /* _REACT_NATIVE_HASKELL_SHELLEY_ */
